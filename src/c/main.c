#include <pebble.h>
#include "main.h"
static Window *s_window;
static TextLayer *s_text_layer;

ClaySettings settings;

static void prv_default_settings() {
  strcpy(settings.bigGMT, "localtime");
  strcpy(settings.smallGMT, "utc+0200");
}

static void prv_load_settings() {
  prv_default_settings();
  // Read settings from persistent storage, if they exist
  persist_read_data(SETTINGS_KEY, &settings, sizeof(settings));
}

static void prv_save_settings() {
  persist_write_data(SETTINGS_KEY, &settings, sizeof(settings));

  //prv_update_display(); //TODO?
  time_t now = time(NULL);
  struct tm *tick_time = localtime(&now);
  prv_display_time(tick_time);
}

static void prv_inbox_received_handler(DictionaryIterator *iter, void *context) {
  Tuple *bigGMT_t = dict_find(iter, MESSAGE_KEY_bigGMT);
  if (bigGMT_t) {
    strcpy(settings.bigGMT, bigGMT_t->value->cstring);
  }

  Tuple *smallGMT_t = dict_find(iter, MESSAGE_KEY_smallGMT);
  if (smallGMT_t) {
    strcpy(settings.smallGMT, smallGMT_t->value->cstring);
  }
  // Save the new settings to persistent storage
  prv_save_settings();
}

// Slot on-screen layout:
//     0 1
//     2 3
#define TOTAL_IMAGE_SLOTS 4
#define NUMBER_OF_IMAGES 10

// These images are 72 x 84 pixels (i.e. a quarter of the Aplite display),
// black and white with the digit character centered in the image.
// (As generated by the `fonttools/font2png.py` script.)
const int IMAGE_RESOURCE_IDS[NUMBER_OF_IMAGES] = {
  RESOURCE_ID_IMAGE_NUM_0, RESOURCE_ID_IMAGE_NUM_1, RESOURCE_ID_IMAGE_NUM_2,
  RESOURCE_ID_IMAGE_NUM_3, RESOURCE_ID_IMAGE_NUM_4, RESOURCE_ID_IMAGE_NUM_5,
  RESOURCE_ID_IMAGE_NUM_6, RESOURCE_ID_IMAGE_NUM_7, RESOURCE_ID_IMAGE_NUM_8,
  RESOURCE_ID_IMAGE_NUM_9
};

static GBitmap *s_images[TOTAL_IMAGE_SLOTS];
static BitmapLayer *s_image_layers[TOTAL_IMAGE_SLOTS];

#define EMPTY_SLOT -1

// The state is either "empty" or the digit of the image currently in the slot.
static int s_image_slot_state[TOTAL_IMAGE_SLOTS] = {
  EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT
};

// Loads the digit image from the application's resources and
// displays it on-screen in the correct location.
// Each slot is a quarter of the screen.
static void load_digit_image_into_slot(int slot_number, int digit_value) {
  GRect bounds = layer_get_bounds(window_get_root_layer(s_window));
  GRect tile_bounds = gbitmap_get_bounds(s_images[slot_number]);

  s_image_slot_state[slot_number] = digit_value;
  s_images[slot_number] = gbitmap_create_with_resource(IMAGE_RESOURCE_IDS[digit_value]);

  const int x_offset = (bounds.size.w - (2 * tile_bounds.size.w)) / 2;
  int y_offset = 0;
  switch(slot_number){
    case 0:
      y_offset = (bounds.size.h - (2 * tile_bounds.size.h)) / 2 -5;
    break;
    case 1:
      y_offset = (bounds.size.h - (2 * tile_bounds.size.h)) / 2 -5;
    break;
    case 2:
      y_offset = (bounds.size.h - (2 * tile_bounds.size.h)) / 2 +5;
    break;
    case 3:
      y_offset = (bounds.size.h - (2 * tile_bounds.size.h)) / 2 +5;
    break;
  }
  BitmapLayer *bitmap_layer = bitmap_layer_create(
    GRect(x_offset + ((slot_number % 2) * tile_bounds.size.w),
      y_offset + ((slot_number / 2) * tile_bounds.size.h),
      tile_bounds.size.w, tile_bounds.size.h));
  s_image_layers[slot_number] = bitmap_layer;
  bitmap_layer_set_bitmap(bitmap_layer, s_images[slot_number]);

  Layer *window_layer = window_get_root_layer(s_window);
  layer_remove_from_parent(text_layer_get_layer(s_text_layer));
  layer_add_child(window_layer, bitmap_layer_get_layer(bitmap_layer));
  layer_add_child(window_layer, text_layer_get_layer(s_text_layer));
}

static void unload_digit_image_from_slot(int slot_number) {
  if (s_image_slot_state[slot_number] != EMPTY_SLOT) {
    layer_remove_from_parent(bitmap_layer_get_layer(s_image_layers[slot_number]));
    bitmap_layer_destroy(s_image_layers[slot_number]);
    gbitmap_destroy(s_images[slot_number]);

    // This is now an empty slot
    s_image_slot_state[slot_number] = EMPTY_SLOT;
  }
}

static void display_value(unsigned short value, unsigned short row_number, bool show_first_leading_zero) {
  value = value % 100; // Maximum of two digits per row.

  // Column order is: | Column 0 | Column 1 |
  // (We process the columns in reverse order because that makes
  // extracting the digits from the value easier.)
  for (int column_number = 1; column_number >= 0; column_number--) {
    int slot_number = (row_number * 2) + column_number;
    unload_digit_image_from_slot(slot_number);
    if (!((value == 0) && (column_number == 0) && !show_first_leading_zero)) {
      load_digit_image_into_slot(slot_number, value % 10);
    }
    value = value / 10;
  }
}

static unsigned short get_display_hour(unsigned short hour) {
  if (clock_is_24h_style()) {
    return hour;
  }

  // Converts "0" to "12"
  unsigned short display_hour = hour % 12;
  return display_hour ? display_hour : 12;
}

static int prv_extract_offset(char settingString[], int unit) { //utc-1200

  if (strcmp(settingString, "localtime") == 0 || strcmp(settingString, "disabled") == 0) {
        return 0;
  }
  int offset = -1;
  char offsetstr[3] = "00";
  switch (unit) {
    case HOUR_UNIT:
      strncpy (offsetstr, settingString + 4, 2);
    break;
    case MINUTE_UNIT:
      strncpy (offsetstr, settingString + 6, 2);
    break;
  }
  offsetstr[2] = '\0';

  offset = atoi(offsetstr);

  switch (settingString[3]) { //positive or negative?
    case '+':
      return offset;
    break;
    case '-':
      return -offset;
    break;
  }
  return 0;
}

#define CLOCK_ID_BIG_GMT 0
#define CLOCK_ID_SMALL_GMT 1
static void prv_set_gmt(int clockid) {
  char settingString[10];
  switch (clockid) {
    case CLOCK_ID_BIG_GMT:
      strcpy(settingString, settings.bigGMT);
    break;
    case CLOCK_ID_SMALL_GMT:
      strcpy(settingString, settings.smallGMT);
    break;
  }

  int hourOffset = prv_extract_offset(settingString, HOUR_UNIT);
  int minuteOffset = prv_extract_offset(settingString, MINUTE_UNIT);
  time_t now = time(NULL) + (hourOffset * 60 * 60) + (minuteOffset * 60);
  struct tm *tick_time = gmtime(&now);
  switch(clockid) {
    case CLOCK_ID_BIG_GMT:
      display_value(get_display_hour(tick_time->tm_hour), 0, false);
      display_value(tick_time->tm_min, 1, true);
    break;
    case CLOCK_ID_SMALL_GMT:;
      static char displaybuf[] = "00:00";
      strftime(displaybuf, sizeof(displaybuf), "%H:%M", tick_time);
      text_layer_set_text(s_text_layer, displaybuf);
    break;
  }
}

static void prv_display_time(struct tm *tick_time) {
  if (strcmp(settings.bigGMT, "localtime")==0)
  {
    display_value(get_display_hour(tick_time->tm_hour), 0, false);
    display_value(tick_time->tm_min, 1, true);
  } else {
    prv_set_gmt(CLOCK_ID_BIG_GMT);
  }
  if (strcmp(settings.smallGMT, "disabled")==0){
    text_layer_set_text(s_text_layer, "");
  } else {
    prv_set_gmt(CLOCK_ID_SMALL_GMT);
  }
}

static void handle_minute_tick(struct tm *tick_time, TimeUnits units_changed) {
  prv_display_time(tick_time);
}

static void prv_window_load(Window *window) {
  Layer *window_layer = window_get_root_layer(window);
  GRect bounds = layer_get_bounds(window_layer);

  s_text_layer = text_layer_create(GRect(0, 75, bounds.size.w, 20));
  text_layer_set_text_color(s_text_layer, GColorWhite);
  text_layer_set_background_color(s_text_layer, GColorClear);
  text_layer_set_text(s_text_layer, "Hello World!");
  text_layer_set_text(s_text_layer, settings.smallGMT);
  text_layer_set_text_alignment(s_text_layer, GTextAlignmentCenter);
  layer_add_child(window_layer, text_layer_get_layer(s_text_layer));
  time_t now = time(NULL);
  struct tm *tick_time = localtime(&now);
  prv_display_time(tick_time);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);
}

static void prv_window_unload(Window *window) {
  text_layer_destroy(s_text_layer);
  for (int i = 0; i < TOTAL_IMAGE_SLOTS; i++) {
    unload_digit_image_from_slot(i);
  }
}

static void prv_init(void) {
  prv_load_settings();

  app_message_register_inbox_received(prv_inbox_received_handler);
  app_message_open(128, 128);
  s_window = window_create();
  window_set_background_color(s_window, GColorBlack);
  window_set_window_handlers(s_window, (WindowHandlers) {
    .load = prv_window_load,
    .unload = prv_window_unload,
  });
  const bool animated = true;
  window_stack_push(s_window, animated);

  // Open AppMessage connection
  app_message_register_inbox_received(prv_inbox_received_handler);
  app_message_open(128, 128);
}


static void prv_deinit(void) {
  window_destroy(s_window);
}

int main(void) {
  prv_init();
  app_event_loop();
  prv_deinit();
}
